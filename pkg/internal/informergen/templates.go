package informergen

// TODO
const factoryTemplate = `
//go:build !ignore_autogenerated
// +build !ignore_autogenerated

// Code generated by kcp code-generator. DO NOT EDIT.

package {{.PackageName}}

import (
	reflect "reflect"
	sync "sync"
	time "time"
)

// SharedInformerOption defines the functional option type for SharedInformerFactory.
type SharedInformerOption func(*sharedInformerFactory) *sharedInformerFactory

type sharedInformerFactory struct {
	client {{.clientSetInterface}}
	namespace string
	tweakListOptions internalinterfaces.TweakListOptionsFunc
	lock sync.Mutex
	defaultResync time.Duration
	customResync map[reflect.Type]time.Duration

	informers map[reflect.Type]time.Duration
	// startedInformers is used for tracking which informers have been started.
	// This allows Start() to be called multiple times safely.
	startedInformers map[reflect.Type]bool
}

// WithCustomResyncConfig sets a custom resync period for the specified informer types.
func WithCustomResyncConfig(resyncConfig map[{{.object}}]{{.timeDuration}}) SharedInformerOption {
	return func(factory *sharedInformerFactory) *sharedInformerFactory {
		for k, v := range resyncConfig {
			factory.customResync[reflect.TypeOf(k)] = v
		}
		return factory
	}
}

// WithTweakListOptions sets a custom filter on all listers of the configured SharedInformerFactory.
func WithTweakListOptions(tweakListOptions internalinterfaces.TweakListOptionsFunc) SharedInformerOption {
	return func(factory *sharedInformerFactory) *sharedInformerFactory {
		factory.tweakListOptions = tweakListOptions
		return factory
	}
}

// WithNamespace limits the SharedInformerFactory to the specified namespace.
func WithNamespace(namespace string) SharedInformerOption {
	return func(factory *sharedInformerFactory) *sharedInformerFactory {
		factory.namespace = namespace
		return factory
	}
}

// NewSharedInformerFactory constructs a new instance of sharedInformerFactory for all namespaces.
func NewSharedInformerFactory(client {{.clientSetInterface}}, defaultResync {{.timeDuration}}) SharedInformerFactory {
	return NewSharedInformerFactoryWithOptions(client, defaultResync)
}

// NewFilteredSharedInformerFactory constructs a new instance of sharedInformerFactory.
// Listers obtained via this SharedInformerFactory will be subject to the same filters
// as specified here.
// Deprecated: Please use NewSharedInformerFactoryWithOptions instead
func NewFilteredSharedInformerFactory(client {{.clientSetInterface}}, defaultResync {{.timeDuration}}, namespace string, tweakListOptions {{.interfacesTweakListOptionsFunc}}) SharedInformerFactory {
	return NewSharedInformerFactoryWithOptions(client, defaultResync, WithNamespace(namespace), WithTweakListOptions(tweakListOptions))
}

// NewSharedInformerFactoryWithOptions constructs a new instance of a SharedInformerFactory with additional options.
func NewSharedInformerFactoryWithOptions(client {{.clientSetInterface}}, defaultResync {{.timeDuration}}, options ...SharedInformerOption) SharedInformerFactory {
	factory := &sharedInformerFactory{
		client:           client,
		namespace:        v1.NamespaceAll,
		defaultResync:    defaultResync,
		informers:        make(map[{{.reflectType}}]{{.cacheSharedIndexInformer}}),
		startedInformers: make(map[{{.reflectType}}]bool),
		customResync:     make(map[{{.reflectType}}]{{.timeDuration}}),
	}

	// Apply all options
	for _, opt := range options {
		factory = opt(factory)
	}

	return factory
}

// Start initializes all requested informers.
func (f *sharedInformerFactory) Start(stopCh <-chan struct{}) {
  f.lock.Lock()
  defer f.lock.Unlock()

  for informerType, informer := range f.informers {
    if !f.startedInformers[informerType] {
      go informer.Run(stopCh)
      f.startedInformers[informerType] = true
    }
  }
}

// WaitForCacheSync waits for all started informers' cache were synced.
func (f *sharedInformerFactory) WaitForCacheSync(stopCh <-chan struct{}) map[reflect.Type]bool {
	informers := func()map[reflect.Type]cache.SharedIndexInformer{
               f.lock.Lock()
               defer f.lock.Unlock()

               informers := map[reflect.Type]cache.SharedIndexInformer{}
               for informerType, informer := range f.informers {
                       if f.startedInformers[informerType] {
                               informers[informerType] = informer
                       }
               }
               return informers
       }()

       res := map[reflect.Type]bool{}
       for informType, informer := range informers {
               res[informType] = cache.WaitForCacheSync(stopCh, informer.HasSynced)
       }
       return res
}

// InternalInformerFor returns the SharedIndexInformer for obj using an internal
// client.
func (f *sharedInformerFactory) InformerFor(obj {{.runtimeObject}}, newFunc {{.interfacesNewInformerFunc}}) {{.cacheSharedIndexInformer}} {
  f.lock.Lock()
  defer f.lock.Unlock()

  informerType := reflect.TypeOf(obj)
  informer, exists := f.informers[informerType]
  if exists {
    return informer
  }

  resyncPeriod, exists := f.customResync[informerType]
  if !exists {
    resyncPeriod = f.defaultResync
  }

  informer = newFunc(f.client, resyncPeriod)
  f.informers[informerType] = informer

  return informer
}
`

const genericInformerTemplate = `
//go:build !ignore_autogenerated
// +build !ignore_autogenerated

// Code generated by kcp code-generator. DO NOT EDIT.

package {{.PackageName}}

import (
	apimachinerycache "github.com/kcp-dev/apimachinery/pkg/cache"
	"github.com/kcp-dev/kubernetes/src/k8s.io/client-go/tools/cache"
	"k8s.io/apimachinery/pkg/runtime/schema"

	{{ range .APIs -}}
	{{.Version}} {{.Package}}
	{{ end -}}
)

// GenericInformer is type of SharedIndexInformer which will locate and delegate to other
// sharedInformers based on type
type GenericInformer interface {
	Informer() cache.SharedIndexInformer
	Lister() apimachinerycache.GenericLister
}

type genericInformer struct {
	informer cache.SharedIndexInformer
	resource schema.GroupResource
}

// Informer returns the SharedIndexInformer.
func (f *genericInformer) Informer() cache.SharedIndexInformer {
	return f.informer
}

// Lister returns the GenericLister.
func (f *genericInformer) Lister() apimachinerycache.GenericLister {
	return example.NewGenericLister(f.Informer().GetIndexer(), f.resource)
}

func (f *sharedInformerFactory) ForResource(resource schema.GroupVersionResource) (GenericInformer, error) {
	switch resource {
	{{ range .APIs -}}
	case {{.Version}}.SchemeGroupVersion.WithResource("{{lower .Kind}}"):
		return &genericInformer{resource: resource.GroupResource(), informer: f.{{upper .Group}}().{{upper .Version}}().{{upper .Plural}}().Informer()}, nil
	{{ end -}}
	}

	return nil, fmt.Errorf("no informer found for %v", resource)
}
`

//
const groupInterfaceTemplate = `
//go:build !ignore_autogenerated
// +build !ignore_autogenerated

// Code generated by kcp code-generator. DO NOT EDIT.

{{$group := (lower .Group)}}
package {{$group}}

import (
{{$groupInformerPackage := (printf "%s/%s" .InformerPackage $group)}}
	informers "{{$groupInformerPackage}}"
{{range $version := .Versions -}}
	informers{{$version}} "{{$groupInformerPackage}}/{{$version}}"
{{end -}}
)

type Interface interface {
{{ range $version := .Versions -}}
	{{upper $version}}() informers{{$version}}.Interface
{{ end -}}
}

type group struct {
	delegate informers.Interface
}

func New(delegate informers.Interface) Interface {
	return &group{delegate: delegate}
}

`

// versionInterfaceTemplate generates <output-dir>/externalversions/<group>/<version>/interface.go
const versionInterfaceTemplate = `
//go:build !ignore_autogenerated
// +build !ignore_autogenerated

// Code generated by kcp code-generator. DO NOT EDIT.

package {{.Version}}

import (
	informers "{{.InformerPackage}}/{{.Group}}/{{.Version}}"
)

type Interface interface {
{{ range .APIs -}}
  {{.Plural}}() {{.Kind}}Informer
{{ end -}}
}

type version struct {
	delegate informers.Interface
}

func New(delegate informers.Interface) Interface {
	return &version{delegate: delegate}
}

{{ range .APIs -}}
func (v *version) {{.Plural}}() {{.Kind}}Informer {
	return &{{lower .Kind}}Informer{
		delegate: v.delegate.{{.Kind}}s(),
	}
}
{{ end -}}
`

const informerTemplate = `
//go:build !ignore_autogenerated
// +build !ignore_autogenerated

// Code generated by kcp code-generator. DO NOT EDIT.

package {{.Version}}

import (
	"github.com/kcp-dev/kubernetes/src/k8s.io/client-go/tools/cache"

	informers "{{.InformerPackage}}/{{lower .Group}}/{{.Version}}"
	listers "{{.ListerPackage}}/{{lower .Group}}/{{.Version}}"
)

type {{.Kind}}Informer interface {
	Informer() cache.SharedIndexInformer
	Lister() listers.{{.Kind}}Lister
}

{{$informerType := (lower .Kind | printf "%sInformer")}}
type {{$informerType}} struct {
	delegate informers.{{.Kind}}Informer
}

func (r *{{$informerType}}) Informer() cache.SharedIndexInformer {
	return r.delegate.Informer()
}

func (r *{{$informerType}}) Lister() listers.{{.Kind}}Lister {
	return listers.New{{.Kind}}Lister(r.delegate.Informer().GetIndexer())
}
`
