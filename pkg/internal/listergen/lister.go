package listergen

import (
	"io"
	"text/template"

	"github.com/kcp-dev/code-generator/pkg/parser"
	"k8s.io/code-generator/cmd/client-gen/types"
)

type Lister struct {
	APIPath string
	Group   parser.Group
	Version types.PackageVersion
	Kind    parser.Kind
}

func (l *Lister) WriteContent(w io.Writer) error {
	templ, err := template.New("lister").Funcs(templateFuncs).Parse(lister)
	if err != nil {
		return err
	}

	m := map[string]interface{}{
		"apiPath": l.APIPath,
		"group":   l.Group,
		"version": l.Version,
		"kind":    &l.Kind,
	}
	return templ.Execute(w, m)
}

var lister = `
//go:build !ignore_autogenerated
// +build !ignore_autogenerated

// Code generated by kcp code-generator. DO NOT EDIT.
package {{.version.String}}

import (
	
	{{.group.Name}}{{.version.String}} "{{.apiPath}}"
	"github.com/kcp-dev/logicalcluster"
	"k8s.io/client-go/tools/cache"
	"k8s.io/apimachinery/pkg/labels"
	"k8s.io/apimachinery/pkg/api/errors"
	apimachinerycache "github.com/kcp-dev/apimachinery/pkg/cache"
)

// {{.kind.String}}Lister helps list {{.group.Name}}{{.version.String}}{{.kind.String}}.
// All objects returned here must be treated as read-only.
type {{.kind.String}}ClusterLister interface {
	// List lists all {{.group.Name}}{{.version.String}}{{.kind.String}} in the indexer.
	// Objects returned here must be treated as read-only.
	List(selector labels.Selector) (ret []*{{.group.Name}}{{.version.String}}.{{.kind.String}}, err error)

	// Cluster returns an object that can list and get {{.group.Name}}{{.version.String}}.{{.kind.String}} from the given logical cluster.
	Cluster(cluster logicalcluster.Name) {{.kind.String}}Lister
}

// {{lowerFirst .kind.String}}ClusterLister implements the {{.kind.String}}ClusterLister interface.
type {{lowerFirst .kind.String}}ClusterLister struct {
	indexer cache.Indexer
}

// New{{.kind.String}}ClusterLister returns a new {{.kind.String}}ClusterLister.
func New{{.kind.String}}ClusterLister(indexer cache.Indexer) {{.kind.String}}ClusterLister {
	return &{{lowerFirst .kind.String}}ClusterLister{indexer: indexer}
}

// List lists all {{.group.Name}}{{.version.String}}.{{.kind.String}} in the indexer.
func (s *{{lowerFirst .kind.String}}ClusterLister) List(selector labels.Selector) (ret []*{{.group.Name}}{{.version.String}}.{{.kind.String}}, err error) {
	err = cache.ListAll(s.indexer, selector, func(m interface{}) {
		ret = append(ret, m.(*{{.group.Name}}{{.version.String}}.{{.kind.String}}))
	})
	return ret, err
}

// Cluster returns an object that can list and get {{.group.Name}}{{.version.String}}.{{.kind.String}}.
func (s *{{lowerFirst .kind.String}}ClusterLister) Cluster(cluster logicalcluster.Name) {{.kind.String}}Lister {
	return &{{lowerFirst .kind.String}}Lister{indexer: s.indexer, cluster: cluster}
}

// {{.kind.String}}Lister helps list {{.group.Name}}{{.version.String}}.{{.kind.String}}.
// All objects returned here must be treated as read-only.
type {{.kind.String}}Lister interface {
	// List lists all {{.group.Name}}{{.version.String}}.{{.kind.String}} in the indexer.
	// Objects returned here must be treated as read-only.
	List(selector labels.Selector) (ret []*{{.group.Name}}{{.version.String}}.{{.kind.String}}, err error)
	{{ if .IsNamespaced -}}
	// {{.kind.String}}s returns an object that can list and get {{.group.Name}}{{.version.String}}.{{.kind.String}}.
	{{.kind.String}}s(namespace string) {{.kind.String}}NamespaceLister
	{{ else -}}
	// Get retrieves the {{.group.Name}}{{.version.String}}.{{.kind.String}} from the indexer for a given name.
	// Objects returned here must be treated as read-only.
	Get(name string) (*{{.group.Name}}{{.version.String}}.{{.kind.String}}, error)
	{{ end -}}
}

// {{lowerFirst .kind.String}}Lister implements the {{.kind.String}}Lister interface.
type {{lowerFirst .kind.String}}Lister struct {
	indexer cache.Indexer
	cluster logicalcluster.Name
}

// List lists all {{.group.Name}}{{.version.String}}.{{.kind.String}} in the indexer.
func (s *{{lowerFirst .kind.String}}Lister) List(selector labels.Selector) (ret []*{{.group.Name}}{{.version.String}}.{{.kind.String}}, err error) {
	selectAll := selector == nil || selector.Empty()

	key := apimachinerycache.ToClusterAwareKey(s.cluster.String(), "", "")
	list, err := s.indexer.ByIndex(apimachinerycache.ClusterIndexName, key)
	if err != nil {
		return nil, err
	}

	for i := range list {
		obj := list[i].(*{{.group.Name}}{{.version.String}}.{{.kind.String}})
		if selectAll {
			ret = append(ret, obj)
		} else {
			if selector.Matches(labels.Set(obj.GetLabels())) {
				ret = append(ret, obj)
			}
		}
	}

	return ret, err
}

{{ if  not .IsNamespaced -}}
// Get retrieves the {{.group.Name}}{{.version.String}}.{{.kind.String}} from the indexer for a given name.
func (s {{lowerFirst .kind.String}}Lister) Get(name string) (*{{.group.Name}}{{.version.String}}.{{.kind.String}}, error) {
	key := apimachinerycache.ToClusterAwareKey(s.cluster.String(), "", name)
	obj, exists, err := s.indexer.GetByKey(key)
	if err != nil {
		return nil, err
	}
	if !exists {
		return nil, errors.NewNotFound({{.group.Name}}{{.version.String}}.Resource("{{lowerFirst .kind.String}}"), name)
	}
	return obj.(*{{.group.Name}}{{.version.String}}.{{.kind.String}}), nil
}
{{ else -}}
// {{.kind.String}}s returns an object that can list and get {{.group.Name}}{{.version.String}}.{{.kind.String}}.
func (s *{{lowerFirst .kind.String}}Lister) {{.kind.String}}s(namespace string) {{.kind.String}}NamespaceLister {
	return {{lowerFirst .kind.String}}NamespaceLister{indexer: s.indexer, cluster: s.cluster, namespace: namespace}
}

// {{.kind.String}}NamespaceLister helps list and get {{.group.Name}}{{.version.String}}.{{.kind.String}}.
// All objects returned here must be treated as read-only.
type {{.kind.String}}NamespaceLister interface {
	// List lists all {{.group.Name}}{{.version.String}}.{{.kind.String}} in the indexer for a given namespace.
	// Objects returned here must be treated as read-only.
	List(selector labels.Selector) (ret []*{{.group.Name}}{{.version.String}}.{{.kind.String}}, err error)
	// Get retrieves the {{.group.Name}}{{.version.String}}.{{.kind.String}} from the indexer for a given namespace and name.
	// Objects returned here must be treated as read-only.
	Get(name string) (*{{.group.Name}}{{.version.String}}.{{.kind.String}}, error)
}

// {{lowerFirst .kind.String}}NamespaceLister implements the {{.kind.String}}NamespaceLister interface.
type {{lowerFirst .kind.String}}NamespaceLister struct {
	indexer   cache.Indexer
	cluster   logicalcluster.Name
	namespace string
}

// List lists all {{.group.Name}}{{.version.String}}.{{.kind.String}} in the indexer for a given namespace.
func (s {{lowerFirst .kind.String}}NamespaceLister) List(selector labels.Selector) (ret []*{{.group.Name}}{{.version.String}}.{{.kind.String}}, err error) {
	selectAll := selector == nil || selector.Empty()

	key := apimachinerycache.ToClusterAwareKey(s.cluster.String(), s.namespace, "")
	list, err := s.indexer.ByIndex(apimachinerycache.ClusterAndNamespaceIndexName, key)
	if err != nil {
		return nil, err
	}

	for i := range list {
		obj := list[i].(*{{.group.Name}}{{.version.String}}.{{.kind.String}})
		if selectAll {
			ret = append(ret, obj)
		} else {
			if selector.Matches(labels.Set(obj.GetLabels())) {
				ret = append(ret, obj)
			}
		}
	}
	return ret, err
}

// Get retrieves the {{.group.Name}}{{.version.String}}.{{.kind.String}} from the indexer for a given namespace and name.
func (s {{lowerFirst .kind.String}}NamespaceLister) Get(name string) (*{{.group.Name}}{{.version.String}}.{{.kind.String}}, error) {
	key := apimachinerycache.ToClusterAwareKey(s.cluster.String(), s.namespace, name)
	obj, exists, err := s.indexer.GetByKey(key)
	if err != nil {
		return nil, err
	}
	if !exists {
		return nil, errors.NewNotFound({{.group.Name}}{{.version.String}}.Resource("{{lowerFirst .kind.String}}"), name)
	}
	return obj.(*{{.group.Name}}{{.version.String}}.{{.kind.String}}), nil
}
{{ end -}}
`
